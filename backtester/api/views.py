import json
import os
from django.conf import settings
from django.shortcuts import render
from rest_framework.exceptions import MethodNotAllowed
from rest_framework.views import APIView
from django.contrib.auth import authenticate
from rest_framework.response import Response
# from django.contrib.auth.models import User
# from .models import UserRegistration
from django.contrib.auth import authenticate
from rest_framework_simplejwt.tokens import RefreshToken
from rest_framework.permissions import AllowAny
from rest_framework import serializers, viewsets
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from rest_framework_simplejwt.tokens import RefreshToken
from django.contrib.auth import authenticate
from django.utils import timezone
import datetime
# from .serializers import UserSignUpSerializer, ForgotPasswordSerializer, ResetPasswordSerializer, LoginSerializer, JSONtoCSVSerializer
from .serializers import UserSignUpSerializer, ForgotPasswordSerializer, ResetPasswordSerializer, LoginSerializer
from django.contrib.auth.tokens import default_token_generator
from django.utils.http import urlsafe_base64_encode, urlsafe_base64_decode
from django.utils.encoding import force_bytes
# from django.contrib.auth.models import User
from django.core.mail import send_mail
from rest_framework import status
from rest_framework.response import Response
from django.template.loader import render_to_string
from django.core.mail import EmailMessage
from django.utils.encoding import force_bytes
from django.contrib.auth.hashers import make_password
from rest_framework.permissions import IsAuthenticated
from rest_framework.generics import ListAPIView
from rest_framework import generics
from django.core.mail import send_mail
from django.urls import reverse
from users.models import User
import os
import pandas as pd
# from .serializers import UserSerializer
# from .models import CustomUser

def get_tokens_for_user(user):
    refresh = RefreshToken.for_user(user)
    return {
        'refresh': str(refresh),
        'access': str(refresh.access_token),
    }

class LoginView(APIView):
    permission_classes = [AllowAny]
    def post(self, request):
        serializer = LoginSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        data = serializer.validated_data
        email = data['email'].lower() 
        user = authenticate(username=email, password=data['password'])
        if not user:
            raise serializers.ValidationError({'detail': 'Incorrect email or password'})

        refresh = RefreshToken.for_user(user)
        print(refresh.access_token,' From use login')
        user_token= get_tokens_for_user(user)
        print(user_token,' Generated by get user function')
        user.login_datetime= datetime.datetime.now()
        user.save()
        return Response({
            'access': str(refresh.access_token),
            'refresh': str(refresh),
            'id' : user.id,
            'name': user.name,
            'email': user.email,
            'phone_no': user.phone_no,
            'user_type': user.user_type,
            'gst_no': user.gst_no,
            'pincode': user.pincode,
            'pan_no': user.pan_no,
            'country': user.country,
            'state': user.state,
            'address': user.address
        }, status=status.HTTP_200_OK)

class UserSignUp(viewsets.ModelViewSet):

    permission_classes = [AllowAny]
    queryset = User.objects.all()
    # queryset = UserRegistration.objects.all()
    serializer_class = UserSignUpSerializer

    def create(self, request, *args, **kwargs):
        serializer = self.get_serializer(data=request.data)
        email = request.data.get('email').lower()
        name = request.data.get('name')

        if User.objects.filter(email=email).exists():
            return Response({"email": ["This email is already registered."]}, status=status.HTTP_400_BAD_REQUEST)
        # if User.objects.filter(name=name).exists():
        #     return Response({"username": ["This username is already taken."]}, status=status.HTTP_400_BAD_REQUEST)
        
        if serializer.is_valid():
            self.perform_create(serializer)
            headers = self.get_success_headers(serializer.data)
            return Response({'message': 'User created successfully'}, status=201)
            # return Response(serializer.data, status=status.HTTP_201_CREATED, headers=headers)
        else:
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

class ForgotPasswordView(APIView):
    permission_classes = [AllowAny]  # Allow access to anyone

    def post(self, request):
        serializer = ForgotPasswordSerializer(data=request.data)
        if serializer.is_valid():
            email = serializer.validated_data['email']
            try:
                user = User.objects.get(email=email)
            except User.DoesNotExist:
                return Response({"message": "User with this email does not exist."}, status=status.HTTP_404_NOT_FOUND)
            
            # Generate password reset token and uid
            token = default_token_generator.make_token(user)
            uid = urlsafe_base64_encode(force_bytes(user.pk))
            
            # Build password reset link
            reset_url = reverse('password_reset_confirm', kwargs={'uidb64': uid, 'token': token})
            reset_link = request.build_absolute_uri(reset_url)
            
            # Send password reset email
            email_subject = "Password Reset"
            email_body = render_to_string("password_reset_email.html", {'reset_link': reset_link})
            email = EmailMessage(
                email_subject,
                email_body,
                to=[email],
            )
            email.content_subtype = "html"  # Set the content type to HTML
            email.send(fail_silently=False)

            return Response({"message": "Password reset email sent."}, status=status.HTTP_200_OK)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

class ResetPasswordView(APIView):
    permission_classes = [AllowAny]  # Allow access to anyone

    def post(self, request):
        serializer = ResetPasswordSerializer(data=request.data)
        if serializer.is_valid():
            email = serializer.validated_data['email']
            new_password = serializer.validated_data['new_password']

            try:
                user = User.objects.get(email=email)
            except User.DoesNotExist:
                return Response({"message": "User not found."}, status=status.HTTP_404_NOT_FOUND)

            # Update user's password
            user.set_password(new_password)
            user.save()
            return Response({"message": "Password reset successfully."}, status=status.HTTP_200_OK)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

# class JSONtoCSV(APIView):
#     def post(self, request, format=None):
#             serializer = JSONtoCSVSerializer(data=request.data)
            
#             if serializer.is_valid():
#                 data = serializer.validated_data
#                 data = json.dumps(data)
#                 print(data)
#                 data = json.loads(data)
#                 main_id = data.get('id', '')

#                 # w_t_strategy_data = data['w_t_strategy']
#                 w_t_strategy_data = data.get('w_t_strategy')

#                 data_w_t_strategy = pd.DataFrame(w_t_strategy_data)

#                 main_data = {key: value for key, value in data.items() if key != 'w_t_strategy'}
#                 data_main = pd.DataFrame([main_data])

#                 print("DataFrame for the main dictionary:")
#                 print(data_main)

#                 print("\nDataFrame for the dictionaries inside w_t_strategy:")
#                 print(data_w_t_strategy)
#                 data_main1=data_main.T
#                 data_w_t_strategy1=data_w_t_strategy.T
#                 data = pd.concat([data_w_t_strategy1, data_main1])
#                 data = data.T
                
#                 data1 = {
#                 'closest_premium_value': 'diffentry',
#                 'target_type': 'wnt_selectiontype',
#                 'target_up_down': 'inc_decwt',
#                 'exit_target': 'target_diff',
#                 'exit_stop_loss': 'sl_diff',
#                 'qty':'quantity',
#                 'strick_distance':'diffentry1',
#                 'mtom_target':'mtm_target_points',
#                 'mtom_stop_loss':'mtm_sl_points',
#                 'mtom_sl_movement':'mtm_sl_move',
#                 'closest_premium_type':'closesttype',
#                 'trailing_sl_target_type':'tr_selectiontype',
#                 'trailing_sl_movement':'sl_point',

#                 'trailing_target_movement':'tr_point',
#                 'mtom_target_movement':'mtm_y',
#                 'mtom_trailing_value':'mtm_x',
#                 'option_type' : 'optiontype',
#                 'action_type':'tradetype',
#                 'start_time': 'entrytime',
#                 'end_time': 'exittime',
#                 'selection_type':'entrytype',
#                 'strick_type':'moneyness',
#                 'trailing_sl':'trailingsl',
#                 'wait_and_trade':'waitntrade',
#                 'mtom_trailing_sl' : 'mtm_sl_trail',
#                 're_entry_execute_on_sl':'re_entry_sl',
#                 're_entry_execute_on_target':'re_entry_target'

#                 }

                

#                 data['target_diff'] = pd.to_numeric(data['target_diff'], errors='coerce')
#                 data['sl_diff'] = pd.to_numeric(data['sl_diff'], errors='coerce')

#                 # Initialize columns with False
#                 data['target_flag'] = False
#                 data['sl_flag'] = False
#                 data['mtm_target'] = False
#                 data['mtm_sl'] = False
#                 data['mtm_entry'] = False
#                 data['re_execute_leg'] = False
#                 data['re_entry_leg'] = False

#                 data['daysofweek']='0,1,2,3,4'

#                 data['total_premium_exit']=False
#                 data['total_premium_type']='POINT'
#                 data['total_premium_inc']=20
#                 data['total_premium_dec']=20

#                 data['sl_to_cost']=False
#                 data['square_off_both_leg']=False
#                 data['start']=False
#                 data['missquareoff']=True
#                 data['option']=False
#                 data['optiontrade']=False
#                 data['target']=0
#                 data['stoploss']=0
#                 data['startingltp']=0
#                 data['entrytrigger']=0
#                 data['tr_ltp']=0
#                 data['tr_target']=0
#                 data['trail_flag']=False
#                 data['straddle']=False
#                 data['strategy_flag']=True
#                 data['target_type']=None
#                 data['sl_type']=None
#                 data['re_entry_count']=0
#                 data['re_entry_times']=1
#                 data['re_execute_count']=0
#                 data['re_execute_times']=1
                
#                 # Conditions for target_flag and sl_flag
#                 data.loc[(data['target_diff'] == 10000.0) & (data['sl_diff'] == 10000.0), ['target_flag', 'sl_flag']] = False
#                 data.loc[(data['target_diff'] != 10000.0) & (data['sl_diff'] == 10000.0), 'target_flag'] = True
#                 data.loc[(data['target_diff'] == 10000.0) & (data['sl_diff'] != 10000.0), 'sl_flag'] = True
#                 data.loc[(data['target_diff'] != 10000.0) & (data['sl_diff'] != 10000.0), ['target_flag', 'sl_flag']] = True

#                 # Conditions for re_entry_leg and re_execute_leg
#                 # data.loc[data['re_entry']] = True
#                 # data.loc[data['re_execute']] = True

#                 for i in range(len(data)):

#                     if data['is_mtm_activated'][i]==True:
#                         data['mtm_target'][i]=True
#                         data['mtm_sl'][i]=True
#                         data['mtm_entry'][i]=True    

#                     if data['exit_target_type'][i]=="POINTS":
#                         data['target_type'][i]='POINTS'
#                         data['sl_type'][i]='POINTS'
#                     elif data['exit_target_type'][i]=="PERCENTAGE":
#                         data['target_type'][i]='PERCENTAGE'
#                         data['sl_type'][i]='PERCENTAGE'
#                 # Conditions for mtm_target, mtm_sl, mtm_entry
#                 # data.loc[data['is_mtm_activated'], ['mtm_target', 'mtm_sl', 'mtm_entry']] = True

#                 data = data.T
                
#                 # csv_path = 'files'

#                 csv_filename = f"nifty_legs_{main_id}.csv"

#                 if os.path.exists(csv_filename):
#                     os.remove(csv_filename)
                
#                 # csv_file_path = os.path.join(csv_path, csv_filename)

#                 data.to_csv(csv_filename)

#                 return Response({'message': 'Preprocessing completed successfully.'}, status=200)
#         # return Response(serializer.errors, status=400) 
#             return Response("Hello", status=400) 

# class UserRetrieveAPIView(generics.RetrieveAPIView):
#     queryset = CustomUser.objects.all()
#     serializer_class = UserSerializer
#     lookup_field = 'username'  # You can use any field to look up users
